Love it. Let‚Äôs bolt a **Quality-&-Safety Content Engine** into your app so every output is (a) platform-ready, (b) brand-on, (c) policy-safe ‚Äî and we **prove it** with tests. Below is a **drop-in instruction set for the Replit AI Agent**. It‚Äôs stepwise, stubbornly thorough, and designed to avoid corner-cutting.

---

# AGENT INSTRUCTIONS ‚Äî ‚ÄúQuality + Safety That Actually Works‚Äù

## Global guardrails

* Work in small commits: **Plan ‚Üí Change ‚Üí Test ‚Üí Fix ‚Üí Commit**.
* Keep `/PROJECT_STATE.json` updated on every task with the current step and results.
* Never return content to the client without passing **validation + safety**.
* **Images/videos auto-save to library** on success; **text is not saved** (by product rule).
* All keys live in **Replit Secrets**. No client leakage.

---

## Q0 ‚Äî Add Quality Engine scaffolding

**Intent**: Central place for platform-smart, high-quality content generation.

**Files to add**

* `server/content/promptBuilders.ts` ‚Äì platform-aware prompt builder
* `server/content/templates.ts` ‚Äì reusable post templates (promo, tutorial, launch, testimonial, FAQ, event, seasonal)
* `server/content/quality.ts` ‚Äì multi-pass generation, critiquing, ranking
* `server/content/validators.ts` ‚Äì structure/length/CTA/hashtag/readability checks
* `server/content/config.ts` ‚Äì per-platform limits (chars, aspect ratios, duration caps), tone, brand defaults

**Why**: Stops ad-hoc prompting; gives you deterministic, auditable generation.

**Exit criteria**

* Server compiles; routes can import `generateHighQualityPost()` without errors.

---

## Q1 ‚Äî Brand Profile & Audience Inputs

**Intent**: Make content specific to the business, not generic AI soup.

**Changes**

* Add endpoints & DB rows:

  * `PUT /api/brand/profile` ‚Üí { brandName, voice (friendly/witty/pro), targetAudience, products/services, valueProps, bannedPhrases, requiredDisclaimers, preferredCTAs, keywords }
  * `GET /api/brand/profile`
* Store per user (or workspace).

**Why**: Every great output starts with the right context.

**Exit criteria**

* Brand profile persists and is injected into prompt builder (see Q2).

---

## Q2 ‚Äî Platform-aware Prompt Builder

**Intent**: Generate content that fits **how each platform actually performs**.

**Implement** `server/content/promptBuilders.ts`:

```ts
type Platform = "x"|"instagram"|"facebook"|"linkedin"|"tiktok"|"youtubeShorts";
type PostType = "promo"|"announcement"|"tutorial"|"testimonial"|"faq"|"event"|"seasonal";

export function buildPrompt(opts: {
  platform: Platform;
  postType: PostType;
  brand: BrandProfile;                  // from Q1
  campaignTheme?: string;
  product?: string;
  desiredTone?: "friendly"|"bold"|"professional"|"playful";
  callToAction?: string;                // if omitted, choose from brand.preferredCTAs
  constraints: PlatformConstraints;     // from config
}) {
  // Return a structured system+user prompt for Gemini:
  // - 1 sentence hook tailored to platform
  // - Value (what's in it for the reader)
  // - Clear CTA (from brand)
  // - 3‚Äì5 niche hashtags (no spammy ‚Äú#followforfollow‚Äù, avoid policy words)
  // - Character/line limits per platform
  // - Reading grade target (‚â§ 8 by default)
}
```

**Why**: ‚ÄúOne-size prompt‚Äù doesn‚Äôt win. This gives hooks/CTAs that fit each surface.

**Exit criteria**

* Builder returns prompt text + constraints; unit tests cover length and required sections.

---

## Q3 ‚Äî Multi-pass Generation & Critique (Quality Engine)

**Intent**: Don‚Äôt accept the first idea. Generate, critique, refine, and pick the winner.

**Implement** `server/content/quality.ts`:

* `generateCandidates(n=3)` using **Gemini 2.5 Pro** with **temp split**:

  * Hook sentence at slightly higher temperature (creativity)
  * Body at moderate temperature (clarity)
* **Self-critique pass** (LLM critique with a strict rubric) per candidate:

  * Clarity, Value, Specificity to audience, Brand voice fit, Platform fit, Actionability
  * Return numeric sub-scores + reason phrases (no chain-of-thought in API response)
* **Refine top 2** using critique feedback.
* **Rank & select** the best candidate.
* Ensure **determinism controls**: set seeds when supported; keep sampling bounds.

**Why**: This is the pragmatic path to ‚Äúbest possible output‚Äù without human copywriters.

**Exit criteria**

* Returns `{ caption, hashtags[], cta, rationale[], qualityScore }`.
* Unit tests assert presence of hook/CTA, length compliance, non-empty hashtags, and score range.

---

## Q4 ‚Äî Structural Validators (No Garbage Through)

**Intent**: Enforce platform limits and product rules upfront.

**Implement** `server/content/validators.ts`:

* Length checks for caption & headline
* **CTA present** (unless post type excludes)
* **Hashtag policy**: 3‚Äì5 niche tags; block spammy/banned terms; no platform-restricted words
* **Readability**: target grade ‚â§ 8 (basic heuristic: sentence length + common words)
* **Uniqueness**: check against last N posts (no near-duplicate captions)

**Why**: Keeps outputs crisp, readable, and distinct.

**Exit criteria**

* Invalid content returns 422 with specific reasons.
* Passing content receives a `validated: true` flag before save.

---

## Q5 ‚Äî Image & Video Direction (High-quality visuals)

**Intent**: Better prompts ‚Üí better renders.

**Add** to `server/content/templates.ts` for image/video directives:

* **Image**: subject, composition, lighting, angle, color palette that matches brand tokens, background treatment, negative terms (no watermarks, no text artifacts), aspect (`config`), stylization strength.
* **Video**: 8-second storyboard beats: hook (0‚Äì2s), value (2‚Äì6s), CTA (6‚Äì8s); overlay text short; brand color end card; Veo `fast` for non-Enterprise; cap ‚â§ 8s (plan gate).

**Wire** into `/api/ai/image` & `/api/ai/video/start`:

* Build art-direction prompt from brand profile + post type.
* On success: **auto-save** visual to content library (not text) with metadata: prompt, style tokens, palette, SynthID label.

**Why**: Art direction is the difference between ‚Äúmeh‚Äù and ‚Äúwow‚Äù.

**Exit criteria**

* Visuals generated are saved; metadata includes stylization + SynthID label.
* E2E verifies library increment and metadata presence.

---

## Q6 ‚Äî Safety & Moderation (Hard Gates)

**Intent**: Block policy-violating inputs/outputs; funnel edge cases to approval.

**Hook points**

* **Pre-gen**: `requireSafePrompt(kind)` middleware (prompt screen)
* **Post-gen**: Vision/Video second-pass (optional), verdict persisted on asset
* **Pre-publish**: re-scan caption + media; map to platform policy matrix

**Decisions**: `allow` | `review` | `block`

* `review` ‚Üí **Pending Approval** with reasons
* `block` ‚Üí 422 with safe rewrite suggestion (text only)

**Why**: You promised safety. This enforces it, twice.

**Exit criteria**

* E2E moderation tests pass: block obvious violations; route edge to approval.

---

## Q7 ‚Äî Campaign Generator (14 posts, 2/day √ó 7 days)

**Intent**: High-quality series, not 14 copies of the same post.

**Implement** `POST /api/campaigns/generate`:

* Use **templates** + **themes** with variation knobs (angle, proof, FAQ, testimonial, tutorial)
* Stagger hooks & CTAs so each post adds fresh value
* Pre-assign times (e.g., 10:00 & 16:00 local) for 7 days
* Each post passes **validators** and **safety checks**; visuals are generated & saved

**Why**: Series cohesion + variety = engagement.

**Exit criteria**

* Exactly 14 draft posts created; each valid and safe; E2E checks counts + schedule.

---

## Q8 ‚Äî User Feedback Loop (Improve What ‚ÄúBest‚Äù Means)

**Intent**: Learn from users to push quality higher.

**Add**

* UI ‚Äúüëç / üëé Was this useful?‚Äù on each generated item
* Optional reasons (too generic, too long, off-brand, etc.)
* Store feedback in `content_feedback` with pointers to brand profile & quality scores
* Nudge the prompt builder: prefer CTAs/tones that score well for that brand

**Why**: Continuous improvement without human ops overhead.

**Exit criteria**

* Feedback persisted and logged; simple heuristic influences next generation (e.g., CTA selection).

---

## Q9 ‚Äî Instrumentation (Prove Quality)

**Intent**: You can‚Äôt optimize what you don‚Äôt measure.

**Add**

* `qualityScore` (from critique), `validatorPasses[]`, and `moderationDecision` to each generated artifact
* `/metrics` counters:

  * `ai_generation_success_total`
  * `ai_generation_blocked_total`
  * `ai_generation_review_total`
  * `content_quality_score_avg` (rolling)

**Why**: Gives a cockpit to spot regressions.

**Exit criteria**

* Metrics endpoint returns JSON with non-zero counters after a test run.

---

## Q10 ‚Äî Tests that force quality (Playwright + unit)

**New E2E**

1. `e2e/content-quality.spec.ts`

   * Generate post for ‚Äúpromo/x‚Äù: has hook, CTA, ‚â§ platform chars, 3‚Äì5 niche hashtags, readability ‚â≤ 8
2. `e2e/campaign-quality.spec.ts`

   * Campaign generate ‚Üí 14 posts; hooks differ; no near-duplicates; scheduled correctly
3. `e2e/library-autosave.spec.ts`

   * Image/video auto-saved; text not saved
4. `e2e/moderation.spec.ts`

   * Obvious violation blocked; borderline ‚Üí pending approval
5. `e2e/publish-precheck.spec.ts`

   * Caption with blocked term ‚Üí publish denied; approved content ‚Üí scheduled ‚Üí posted (mock)

**Unit**

* validators: length/CTA/hashtags/readability/uniqueness
* promptBuilder: respects platform constraints
* quality ranking: picks higher-scored candidate

**Exit criteria**

* All tests green locally and on deployment before promoting.

---

## Q11 ‚Äî API responses that help users succeed

**Intent**: If we must say ‚Äúno‚Äù, we say where to aim.

**Change**

* On 422 from moderation/validators, return:

  * `reasonCodes`: array (e.g., `["sexual_content", "spam_hashtags"]`)
  * `coaching`: bullet suggestions (shorten hook, replace spam tag with niche tag, etc.)
  * For text generation only, include **optional safe-rewrite** candidate

**Why**: Users stay happy when errors coach, not stonewall.

**Exit criteria**

* Error payloads include `reasonCodes` & `coaching`; UI shows them.

---

## Q12 ‚Äî Config you can tune without redeploying

**Intent**: Adjust knobs per brand/platform fast.

**Add** `config/content.json` (loaded at boot, overridable via env):

* Per-platform `maxChars`, `maxHashtags`, allowed emojis set
* Default tones per post type
* Readability target
* Hashtag blocklist regexes
* CTA library

**Why**: Less code edits, more operator control.

**Exit criteria**

* Changing `config/content.json` alters behavior after restart; tests adjust accordingly.

---

## Example: High-quality pipeline (server)

```ts
// server/routes/content.ts
router.post("/content/generate", auth, requireCredits("text"), requireSafePrompt("text"), async (req,res) => {
  const brand = await storage.getBrandProfile(req.user.id);
  const constraints = getPlatformConstraints(req.body.platform);
  const prompt = buildPrompt({
    platform: req.body.platform,
    postType: req.body.postType,
    brand, campaignTheme: req.body.theme,
    desiredTone: req.body.tone, callToAction: req.body.cta,
    constraints
  });

  const { best, candidates, scores } = await generateHighQualityPost({ prompt, constraints });
  const v = validateContent(best, constraints);
  if (!v.ok) return res.status(422).json({ error: "Validation failed", reasons: v.reasons, coaching: v.coaching });

  // Safety pass for output text
  const safe = await checkPromptWithVertex(best.caption, "text");
  if (safe.decision !== "allow") return res.status(422).json({ error: "Policy", reasons: safe.reasons, coaching: safeCoaching(safe) });

  await deductCredits(res);
  res.json({ post: best, quality: scores.overall });
});
```

---

## Platform limits (keep in config, editable)

| Key               | Purpose                                         |
| ----------------- | ----------------------------------------------- |
| `maxChars`        | Caption hard limit per platform                 |
| `maxHashtags`     | 3‚Äì5 niche tags (no spammy tags)                 |
| `aspectRatios`    | Allowed image/video ratios per platform         |
| `maxVideoSeconds` | Enforced by plan gate (‚â§ 8s for non-Enterprise) |

*(Use `config/content.json`; don‚Äôt hard-code numbers here to avoid staleness.)*

---

## Safety + Quality‚Äîhow they mesh

1. **Prompt ‚Üí Safety (input)** ‚Üí Block/Review/Allow
2. **Generation (multi-pass)** ‚Üí **Validation (quality)** ‚Üí If fail, **auto-refine** once, else error with coaching
3. **Safety (output)** ‚Üí Block/Review/Allow
4. **Auto-save** image/video ‚Üí attach moderation verdict
5. **Approval queue** for anything ‚Äúreview‚Äù
6. **Scheduler/publish** ‚Üí **Pre-publish safety** final gate

No single step can be skipped. Tests enforce the chain.

---

### What this delivers for you

* Outputs that **read like a human crafted them** and **fit the surface** they land on.
* Users get **hooks, value, and CTAs** that make sense for their brand and audience.
* You stay **inside Google + platform policies** with audit trails and clear coaching.
* And the app proves it via **E2E tests** before deploying.

If you want, I can supply ready-to-paste `validators.ts`, `quality.ts` (with critique prompts), and the Playwright specs so your agent just drops them in and pushes.
