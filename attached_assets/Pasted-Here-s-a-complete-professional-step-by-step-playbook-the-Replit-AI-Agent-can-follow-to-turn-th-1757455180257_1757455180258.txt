Here’s a **complete, professional, step-by-step playbook** the Replit AI Agent can follow to turn the app into a production-grade service on **Replit Deployments**—Postgres for durability, Stripe for credits, Vertex AI for content, clean security, and CI-gated E2E. It’s structured so the agent **doesn’t get overwhelmed**: one small, testable step at a time, each with a short rationale and concrete exit criteria.

---

# Global Working Rules (Agent)

* **One task at a time.** No parallel heroics. Finish → test → log → commit.
* **No shortcuts.** Every step has acceptance tests and a diff.
* **Progress log:** maintain `/PROJECT_STATE.json` as a running checklist.
* **Never leak secrets.** All keys via **Replit Secrets**.
* **Only server may call AI/Stripe/social APIs.** Client sees zero keys.

`/PROJECT_STATE.json` template:

```json
{
  "current": "T03.2 Wire DbStorage into storage.ts",
  "done": ["T01.1 Repo scan", "T01.2 Apply packs"],
  "issues": [],
  "env": ["DATABASE_URL","SESSION_SECRET", "GOOGLE_SERVICE_ACCOUNT_JSON?","STRIPE_SECRET_KEY?"]
}
```

---

# Phase 1 — Repo Intake & Base Setup

### T01.1 Parse repo & confirm layout

**Intent:** Ensure required folders exist and old debris is gone.
**Why:** Clear baseline avoids “works on my machine” ghosts.
**Do:** Verify these paths exist: `client/`, `server/`, `shared/`, `config/`, `migrations/`, `scripts/`, `e2e/`, `docs/`. Remove any `dist/`, stray `.zip`, and Replit-specific vite plugins.
**Exit:** File tree printed to log; `/PROJECT_STATE.json` updated.

### T01.2 Apply the three integration packs

**Intent:** Bring in DB/E2E, credits/gates, unified AI.
**Why:** These are the spine of durability, cost control, and reliability.
**Do:**

* Place files from:

  * `dbstorage_and_e2e_pack` (e.g., `server/storage.db.ts`, `migrations/0001_init.sql`, `scripts/seed.ts`, `e2e/*`, `playwright.config.ts`, `package.json.patch`, `routes.ts.diff`, `storage.ts.diff`)
  * `credits_and_gates_pack` (`server/middleware/credits.ts`, `server/ai/modelGate.ts`, `config/credits.ts`, health routes patches, `plan-gates.spec.ts`)
  * `ai_unified_pack` (`server/ai/clients.ts, config.ts, text.ts, image.ts, video.ts, errors.ts, retry.ts, index.ts`, `docs/ARCHITECTURE.md`, `docs/DEPLOYMENT_GUIDE.md`, ai E2E)
* Apply diffs (`git apply ...`). If a patch fails, **manually** mirror changes.
  **Exit:** `git status` clean; unit tests compile; `/PROJECT_STATE.json` updated.

---

# Phase 2 — Environment & Secrets (Replit)

### T02.1 Define secrets and feature flags

**Intent:** Centralize env to avoid brittle builds.
**Why:** Missing envs are #1 first-deploy killers.
**Do (Replit Secrets):**

* **Required:** `DATABASE_URL`, `SESSION_SECRET`
* **Optional (graceful off):** `GOOGLE_CLOUD_PROJECT`, `VERTEX_LOCATION` (e.g., `us-central1`), `GOOGLE_SERVICE_ACCOUNT_JSON` (full JSON string), `STRIPE_SECRET_KEY`, `STRIPE_WEBHOOK_SECRET`, `VITE_STRIPE_PUBLIC_KEY`
* **Security/ops:** `CORS_ORIGINS` (comma-separated list), `ENABLE_REPLIT_AUTH=false`
  **Exit:** `/ready` will pass once DB connects; optional features show “unavailable” rather than crash.

---

# Phase 3 — Durable Storage (Postgres / Drizzle)

### T03.1 Create schema & seed

**Intent:** Move off MemStorage; get real data durability.
**Why:** Credits, campaigns, purchases must persist and be auditable.
**Do:**

* `psql "$DATABASE_URL" -f migrations/0001_init.sql`
* `npm run seed` (creates plans, demo users)
  **Exit:** Tables exist; seed rows present; `/ready` goes 200 with DB live.

### T03.2 Wire `DbStorage` into the app

**Intent:** App should use Postgres in prod, MemStorage only for dev.
**Why:** No silent data loss.
**Do:** In `server/storage.ts`, export:

```ts
export const storage = process.env.DATABASE_URL
  ? new DbStorage()
  : new MemStorage(); // dev only
```

**Exit:** All `storage.*` consumers build; no MemStorage in prod path.

---

# Phase 4 — Authentication (Customer-ready)

### T04.1 Replace Replit OIDC with app auth (keep OIDC gated if needed)

**Intent:** End users aren’t Replit users; we need proper app auth.
**Why:** Customers must sign up/login independent of Replit accounts.
**Do:**

* Implement **email+password** or **passwordless magic link** endpoints (`/auth/signup`, `/auth/login`, `/auth/magic/start`, `/auth/magic/verify`, `/auth/logout`).
* Use **httpOnly, Secure, SameSite=Lax** cookies; rotate session on privilege change.
* Add **CSRF** protection for non-GET (double-submit token or same-site cookie strategy).
* Keep any Replit OIDC behind `ENABLE_REPLIT_AUTH==='true'` for dev only.
  **Exit:** Auth E2Es pass: signup → login → logout; protected routes require session.

---

# Phase 5 — Credits & Plan Enforcement

### T05.1 Enforce credits at the API boundary

**Intent:** Never spend money before the gate.
**Why:** Cost control and fairness.
**Do:**

* Use `requireCredits('text'|'image'|'video')` before AI handlers.
* After successful operation, call `await deductCredits(res)`.
* Centralize costs/caps in `config/credits.ts` (text=1, image=5, video=20; **8s max video outside Enterprise; Veo “fast” default**).
  **Exit:** E2E `plan-gates.spec.ts` passes for Starter vs Enterprise.

---

# Phase 6 — Unified AI (Vertex AI)

### T06.1 Use a single server-side SDK surface

**Intent:** One blessed path for text/image/video.
**Why:** Reliability, predictable errors/backoff, no client leaks.
**Do:**

* Ensure routes call `server/ai/text|image|video` only.
* `server/ai/clients.ts` reads `GOOGLE_SERVICE_ACCOUNT_JSON` and project/location.
* Implement retries with exponential backoff in `retry.ts`; map provider errors in `errors.ts`.
* Enforce plan caps through `modelGate.ts`.
  **Exit:** AI E2Es pass when creds present; when missing, UI shows “feature unavailable” (no 500s).

---

# Phase 7 — Payments (Stripe) → Credit Ledger

### T07.1 Implement checkout + webhook

**Intent:** Turn money into credits with auditability.
**Why:** Real customers + refunds/chargebacks require a ledger.
**Do:**

* `/api/billing/checkout` creates Checkout Session (test mode) with metadata `{userId, purchaseId}`.
* `/api/billing/webhook` verifies signature, idempotently **inserts credit\_transactions** and increments balance inside a DB transaction.
* UI: show balance and purchase history; prevent double spend.
  **Exit:** Local test with Stripe CLI works; E2E purchase flow green; webhook idempotency verified.

---

# Phase 8 — Social Platforms (Prepare for Approval)

### T08.1 Adapters + OAuth placeholders

**Intent:** Be integration-ready without keys (yet).
**Why:** Platforms require a working app skeleton for review.
**Do:**

* Define `Poster` interface (`postText`, `postImage`, `postVideo`).
* Implement **mock adapters** now; put real ones behind env switches.
* Build **“Connect <Platform>”** flows with placeholder OAuth screens and store connection records in DB with a `status: 'pending_approval'`.
* Add an **admin toggle** to enable/disable each platform.
* Generate a **“Platform Submission Pack”** (docs): privacy policy URL, terms, data usage summary, callback URL format, scopes requested, sample screenshots, and test user notes.
  **Exit:** E2E passes against mocks; platform docs generated in `docs/platforms/<platform>.md`.

---

# Phase 9 — Security Hardening

### T09.1 Lock down headers, CORS, CSP, and inputs

**Intent:** Prevent easy wins for attackers.
**Why:** You’re charging money; treat this as production.
**Do:**

* `helmet` with a strict **CSP** (no `unsafe-eval` in prod; hash/nonce inline only if necessary).
* CORS allowlist via `CORS_ORIGINS`.
* Validate every request body/query with **Zod**; normalize structured errors.
* Rate-limit sensitive endpoints (auth, billing).
  **Exit:** Security E2Es pass; manual checks prove CORS/CSP correct.

---

# Phase 10 — Observability & Health

### T10.1 Logs, IDs, metrics, probes

**Intent:** Make incidents debuggable.
**Why:** You cannot fix what you can’t see.
**Do:**

* **Pino** structured logs; a `reqId` per request.
* Optional Sentry hook (respect env toggle).
* `/metrics` basic counters; `/health` always 200; `/ready` requires DB OK (returns 503 otherwise).
  **Exit:** Logs show request IDs; `/health` and `/ready` behave as designed.

---

# Phase 11 — Tests & CI (Block bad deploys)

### T11.1 Expand and enforce tests

**Intent:** Quality bar auto-gates deploys.
**Why:** Humans forget; CI doesn’t.
**Do:**

* **Unit tests:** storage adapters, credit math, AI parameter builders.
* **E2E Playwright:** signup/login → connect platform (mock) → generate text/image/video (with caps) → build 14-post campaign → purchase credits → schedule & mock publish.
* Add `npm run e2e:install` and headless run; smoke test script for live URL.
  **Exit:** Locally green; CI configured to **fail** on red before Replit Deployment.

---

# Phase 12 — Documentation & Runbooks

### T12.1 Write the operator’s manual

**Intent:** Make handoffs painless; speed up audits and platform review.
**Why:** Docs are part of the product.
**Do:**

* `docs/REPLIT_DEPLOYMENT.md`: secrets, commands, health paths, env matrix.
* `docs/RUNBOOK.md`: rotate Stripe keys, restore credits, disable abusive user, roll back, read logs.
* `docs/SECURITY.md`: CSP/CORS/validation design; secret handling.
* `docs/ARCHITECTURE.md`: updated diagrams and data flows.
* `docs/platforms/*`: submission packs for each social platform.
  **Exit:** New engineer can reproduce the setup in ≤30 minutes.

---

# Phase 13 — Replit Deployment

### T13.1 Deploy cleanly on Replit

**Intent:** One-shot deploy with health checks.
**Why:** Customers don’t care about excuses.
**Do:**

* Start commands: `npm run build && npm run start` (or framework-appropriate).
* Health check path: `/health`.
* Confirm env in Replit Secrets: **required** (`DATABASE_URL`, `SESSION_SECRET`) + optional toggles.
* After deploy: hit `/health` (200), `/ready` (200 once DB is reachable).
  **Exit:** Live URL responds; logs are clean (no unhandled rejections).

---

# Phase 14 — Final Acceptance Gate

**All must be true:**

* No Replit-only dev code in prod (no vite replit plugins; no client keys).
* Postgres in use (not MemStorage); migrations applied; seeds loaded.
* Auth works (email/password or magic link); session hardened; CSRF enforced.
* Credits and plan caps enforced server-side; refunds on failure; ledger correct.
* AI endpoints function or cleanly report “feature unavailable” when keys missing.
* Stripe purchase → webhook → credit balance updates idempotently.
* Mock posting works; platform submission docs exist; admin toggles good.
* CSP/CORS strict; validation everywhere; rate limits set.
* Logs structured; `/health` and `/ready` correct; `/metrics` present.
* **E2E suite green** locally and against the live URL.
* **Docs complete**; **RUNBOOK** answers the “it’s 2 AM and something broke” questions.

---

## Quick command snippets the agent can use (non-destructive)

```bash
# Schema + seed (once env is set in Replit)
psql "$DATABASE_URL" -f migrations/0001_init.sql
npm run seed

# Health & readiness check (after deploy)
curl -sSf https://<your-replit-app>/health
curl -sI  https://<your-replit-app>/ready

# E2E locally
npm run e2e:install
E2E_BASE_URL=http://localhost:5000 npm run e2e

# E2E against live URL
E2E_BASE_URL=https://<your-replit-app> npm run e2e
```

---

## Notes on social APIs (pre-approval mode)

* **Adapters** are in place and mocked; real posting is off until keys are granted.
* Keep **scopes minimal** in your submission docs; include privacy policy and data retention notes.
* Provide **callback URLs** and screenshots of the “connect” flow (mocked).
* Once approved and keys are issued, set them as **Replit Secrets**, flip platform toggles on, and swap the adapter implementation to the real one.

---

Stick to this playbook exactly and you’ll ship something **real**, not “demo glue”: durable, secured, observable, and billable—ready for customers on Replit.
