1) Reality check (don’t skip)

Veo 3 video via API is paid (AI Studio Pro/Ultra). If your key isn’t on a paid tier, video calls will 403/“unavailable.” It’s capped at 8-second clips and is SynthID-watermarked. 
Gemini
Google AI for Developers

Imagen (image gen) is available through the Gemini API and also watermarks with SynthID. 
Google AI for Developers

You’ll use the Google Gen AI SDK (@google/genai) which works with your Gemini API key. Requires Node 20+. 
Google APIs

2) Replit setup (secrets + deps)

In Replit, open Tools → Secrets and add:

GOOGLE_API_KEY = <your key> (this is the only secret you need for the Gemini API path). 
Replit Docs

Install deps in the Shell:

npm i express cors dotenv @google/genai


package.json (make sure there’s a start script; Replit will use it on Deploy):

{
  "name": "myaimediamgr-ai",
  "type": "module",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "@google/genai": "^1.15.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2"
  }
}


Tip: Don’t set PORT yourself. Replit injects it; your server must listen on process.env.PORT.

3) Drop-in server (one file, three endpoints)

Create server.js in your Repl root:

// server.js
import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import { GoogleGenAI } from '@google/genai';

const app = express();
app.use(cors());
app.use(express.json({ limit: '10mb' }));

// Use your Gemini API key (NOT Vertex)
const ai = new GoogleGenAI({ apiKey: process.env.GOOGLE_API_KEY });

// ---- TEXT: Gemini 2.5 Pro ----
app.post('/api/ai/text', async (req, res) => {
  try {
    const { prompt, system, temperature = 0.9, maxOutputTokens = 2048 } = req.body || {};
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-pro',
      contents: [
        ...(system ? [{ role: 'system', parts: [{ text: system }] }] : []),
        { role: 'user', parts: [{ text: prompt || 'Say ready.' }] }
      ],
      generationConfig: { temperature, maxOutputTokens }
    });
    // SDK exposes a .text string (not a function)
    res.json({ text: response.text });
  } catch (e) {
    console.error('TEXT ERR', e);
    res.status(500).json({ error: e?.message || 'text_generation_failed' });
  }
});

// ---- IMAGE: Imagen 4 ----
app.post('/api/ai/image', async (req, res) => {
  try {
    const {
      prompt,
      aspectRatio = '1:1',     // 1:1, 3:4, 4:3, 9:16, 16:9
      count = 1,               // up to 4
      negativePrompt
    } = req.body || {};

    const r = await ai.models.generateImages({
      model: 'imagen-4.0-generate-001',
      prompt,
      n: Math.min(Math.max(count, 1), 4),
      config: {
        aspectRatio,
        outputMimeType: 'image/png',
        negativePrompt
      }
    });

    // Response shape: generatedImages[].image.imageBytes (Uint8Array or base64)
    const images = (r?.generatedImages || []).map(g => {
      const bytes = g?.image?.imageBytes;
      const b64 = Buffer.isBuffer(bytes)
        ? bytes.toString('base64')
        : (typeof bytes === 'string' ? bytes : Buffer.from(bytes || []).toString('base64'));
      return `data:image/png;base64,${b64}`;
    });

    res.json({ images, watermark: 'SynthID' });
  } catch (e) {
    console.error('IMAGE ERR', e);
    res.status(500).json({ error: e?.message || 'image_generation_failed' });
  }
});

// ---- VIDEO: Veo 3 (start + poll + server-side download proxy) ----
// IMPORTANT: Veo returns a long-running operation you must poll.
app.post('/api/ai/video/start', async (req, res) => {
  try {
    const { prompt, aspectRatio = '16:9', fast = true, negativePrompt } = req.body || {};
    const model = fast ? 'veo-3.0-fast-generate-001' : 'veo-3.0-generate-001';

    const op = await ai.models.generateVideos({
      model,
      prompt,
      config: { aspectRatio, negativePrompt }
    });

    res.json({ operationName: op.name || op.operation || '' });
  } catch (e) {
    console.error('VIDEO START ERR', e);
    res.status(500).json({ error: e?.message || 'video_start_failed' });
  }
});

app.get('/api/ai/video/status/:name', async (req, res) => {
  try {
    const name = req.params.name;
    let op = await ai.operations.getVideosOperation({ operation: { name } });
    if (!op?.done) return res.json({ done: false });

    const vid = op?.response?.generatedVideos?.[0];
    if (!vid) return res.status(500).json({ error: 'no_video_in_response' });

    // Don’t leak your API key to the browser: we’ll proxy the download.
    res.json({
      done: true,
      downloadUrl: `/api/ai/video/download/${encodeURIComponent(name)}`
    });
  } catch (e) {
    console.error('VIDEO STATUS ERR', e);
    res.status(500).json({ error: e?.message || 'video_status_failed' });
  }
});

app.get('/api/ai/video/download/:name', async (req, res) => {
  try {
    const name = req.params.name;
    const op = await ai.operations.getVideosOperation({ operation: { name } });
    const vid = op?.response?.generatedVideos?.[0];
    const uri = vid?.video?.uri;
    if (!uri) return res.status(404).send('no video uri');

    // Some URIs require adding your API key on download. Do it server-side.
    const url = uri.includes('?') ? `${uri}&key=${process.env.GOOGLE_API_KEY}` : `${uri}?key=${process.env.GOOGLE_API_KEY}`;
    const resp = await fetch(url);
    if (!resp.ok) return res.status(502).send('video fetch failed');

    const ab = await resp.arrayBuffer();
    res.setHeader('Content-Type', 'video/mp4');
    res.setHeader('Cache-Control', 'no-store');
    res.send(Buffer.from(ab));
  } catch (e) {
    console.error('VIDEO DL ERR', e);
    res.status(500).json({ error: e?.message || 'video_download_failed' });
  }
});

// Replit requires listening on process.env.PORT and 0.0.0.0
const PORT = process.env.PORT || 8080;
app.listen(PORT, '0.0.0.0', () => {
  console.log(`AI server on :${PORT}`);
});


Why this works:

Text uses gemini-2.5-pro. 
Google Cloud

Image uses imagen-4.0-generate-001 and returns base64 data URLs for straight <img src=...>. 
Google Cloud

Video uses veo-3.0-(fast-)generate-001, polls until done, then proxies the download so your API key never touches the browser. The SDK exposes generateVideos and the corresponding operations.getVideosOperation for polling. 
Google APIs

4) Minimal frontend smoke tests (put in your React app or a quick HTML page)
// TEXT
const t = await fetch('/api/ai/text', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ prompt: 'Say ready.' })
}).then(r => r.json());
console.log(t.text);

// IMAGE
const i = await fetch('/api/ai/image', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    prompt: 'Photoreal espresso on a rustic wood bar, golden hour, steam',
    aspectRatio: '4:3',
    count: 1
  })
}).then(r => r.json());
document.querySelector('#img').src = i.images[0];

// VIDEO (start → poll → download)
const start = await fetch('/api/ai/video/start', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    prompt: 'Cinematic close-up of latte art heart forming in slow motion, soft jazz',
    aspectRatio: '16:9',
    fast: true
  })
}).then(r => r.json());

let uri = '';
while (true) {
  const s = await fetch(`/api/ai/video/status/${encodeURIComponent(start.operationName)}`).then(r => r.json());
  if (s.done) { uri = s.downloadUrl; break; }
  await new Promise(r => setTimeout(r, 5000));
}
document.querySelector('video').src = uri;

5) Deploy on Replit (so it works after “Run” ends)

Click Deploy → choose a type that keeps the server running. Ensure Secrets are included in the deployment environment. (Replit’s Deployments read from the same Secrets manager.) 
Replit Docs

Your server already binds to process.env.PORT on 0.0.0.0—that’s what Replit expects.

6) Troubleshooting you’ll actually hit

403 or “model not available” on Veo 3 → your key isn’t on a paid plan that includes Veo 3. Upgrade in AI Studio or you won’t get video. 
Gemini

Long poll times → normal for video. Keep the 5-10s poll loop; Veo is a long-running operation by design. 
Google APIs

Blank images → you didn’t convert imageBytes to base64 correctly; use the Buffer.from(...).toString('base64') path shown above. The SDK returns generatedImages[].image.imageBytes. 
Google Cloud

Text works locally but not after Deploy → you forgot to add GOOGLE_API_KEY to the Deployed Secrets too.

You now have a single Replit service that cleanly powers Gemini 2.5 Pro, Imagen 4, and Veo 3 with your Gemini key, and it survives deployment. If you want, I’ll fold these routes straight into your MyAiMediaMgr UI (with Veo-Fast by default, 8-sec hard cap, and a nice “Upgrade for quality mode” upsell)