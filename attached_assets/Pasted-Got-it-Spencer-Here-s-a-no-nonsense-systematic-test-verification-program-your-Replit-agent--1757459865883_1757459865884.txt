Got it, Spencer. Here’s a no-nonsense, **systematic test & verification program** your Replit agent can follow to prove—*not claim*—that every feature works, with extra heat on **high-quality content creation (text/image/video + captions)**. It’s step-by-step, includes drop-in files, thresholds, and pass/fail gates. If something fails, the agent loops, fixes, and re-runs until green.

I’m assuming you’ve already integrated the three packs (DB/E2E, Credits/Gates, AI Unified). If not, the agent should do that first.

---

# 0) Preconditions (agent must ensure)

**Intent:** Lock the ground so tests are meaningful.

* DB ready and seeded (`demo-user-1`, `starter-user-1`, plans).
* Auth is testable (use header `x-user-id` in tests).
* AI envs optional; tests must **gracefully skip** AI calls if keys missing and still assert proper HTTP behavior (no 500s).
* Health endpoints online: `/health` = 200 (always), `/ready` = 200 only when DB is reachable.
* Credits middleware on AI routes; plan gates in place (8s non-Enterprise).

**Exit criteria:** `/ready` 200, seeds visible, baseline E2E “health” passes.

---

# 1) Golden Data & Config (add once)

**Intent:** Stable inputs to measure output quality & detect regressions.

Create `tests/golden/content-golden.json`:

```json
{
  "brands": [
    {
      "id": "bakehouse",
      "brandName": "Redbird Bakehouse",
      "voice": "friendly",
      "targetAudience": "local foodies and families",
      "valueProps": ["fresh daily", "local ingredients", "custom cakes"],
      "preferredCTAs": ["Pre-order today", "Visit us", "DM to order"]
    }
  ],
  "scenarios": [
    { "platform": "x", "postType": "promo", "theme": "grand opening", "product": "sourdough loaf" },
    { "platform": "instagram", "postType": "tutorial", "theme": "how to reheat pastries", "product": "croissants" },
    { "platform": "linkedin", "postType": "announcement", "theme": "B2B catering launch", "product": "office catering" }
  ]
}
```

Add thresholds in `tests/quality-thresholds.json`:

```json
{
  "minOverallQuality": 7,
  "maxReadabilityGrade": { "x": 8, "instagram": 8, "linkedin": 10 },
  "hashtagsRange": [3,5]
}
```

**Exit criteria:** Files present; tests can import them.

---

# 2) Add a tiny Quality Evaluator (deterministic)

**Intent:** Score outputs consistently (no flaky “vibes”). Uses your existing `server/content/validators.ts` + a low-temp model critique.

Create `server/content/qualityEvaluator.ts`:

```ts
import { validateContent } from "./validators";
import { PLATFORM_CONSTRAINTS } from "./config";
import { generateText } from "../ai/text";

export type EvalScore = { overall: number; subs: {hook:number;value:number;fit:number;voice:number;action:number} };

export async function scoreCaption(platform: keyof typeof PLATFORM_CONSTRAINTS, caption: string) : Promise<EvalScore> {
  // Deterministic-ish critique at low temperature; fall back to neutral 7s if model unavailable.
  try {
    const prompt = `Score 1-10 for Hook, Value, Platform fit, Voice, Action. Return JSON {"hook":n,"value":n,"fit":n,"voice":n,"action":n}. Caption:\n${caption}`;
    const out = await generateText({ prompt, temperature: 0.0, maxOutputTokens: 100 });
    const j = JSON.parse((out.text || "{}").replace(/^[\s\S]*?(\{)/, "$1"));
    const subs = { hook:+j.hook||7, value:+j.value||7, fit:+j.fit||7, voice:+j.voice||7, action:+j.action||7 };
    const overall = Math.round((subs.hook+subs.value+subs.fit+subs.voice+subs.action)/5);
    return { overall, subs };
  } catch {
    const subs = { hook:7,value:7,fit:7,voice:7,action:7 };
    return { overall:7, subs };
  }
}
```

**Exit criteria:** Compiles; tests can import.

---

# 3) Visual Quality Heuristics (fast, local)

**Intent:** Catch obviously bad images (blank/ultra-blurry) without heavy ML.

Add `server/content/imageHeuristics.ts`:

```ts
import sharp from "sharp";

export async function basicImageQualityScores(pngBytes: Buffer) {
  // Heuristic: variance of Laplacian proxy via sharp (approx with edge magnitude)
  const img = sharp(pngBytes).greyscale();
  const stats = await img.stats();
  // Use stddev as a cheap sharpness correlate (not perfect, but catches blanks/very blurry)
  const sharpness = stats.channels?.[0]?.stdev ?? 0;
  const isBlankish = (stats.channels?.[0]?.mean ?? 0) < 1 && sharpness < 1;
  return { sharpness, isBlankish };
}
```

**Exit criteria:** Available to tests; no native deps beyond `sharp`.

---

# 4) System Self-Test Script (API-level)

**Intent:** One command that walks core flows and prints a pass/fail report.

Create `scripts/system_check.ts`:

```ts
import fetch from "node-fetch";
const base = process.env.CHECK_BASE_URL || "http://localhost:5000";
const user = process.env.CHECK_USER || "starter-user-1";
function hdrs() { return { "x-user-id": user, "content-type": "application/json" }; }

async function expect2xx(path: string, init?: any) {
  const r = await fetch(base+path, init);
  if (!r.ok) throw new Error(`${path} => ${r.status} ${await r.text()}`);
  return r.json().catch(()=> ({}));
}

(async () => {
  const report: any = { ok:false, steps:[] };
  try {
    await expect2xx("/health");
    report.steps.push({ step:"health", ok:true });

    // Brand profile
    await expect2xx("/api/brand/profile", { method:"PUT", headers: hdrs(), body: JSON.stringify({
      brandName:"Redbird Bakehouse", voice:"friendly", targetAudience:"local foodies", valueProps:["fresh daily","local"], preferredCTAs:["Visit us","Pre-order today"]
    })});
    report.steps.push({ step:"brandProfile", ok:true });

    // Text quality generation
    let r = await expect2xx("/api/content/generate", { method:"POST", headers: hdrs(), body: JSON.stringify({
      platform:"x", postType:"promo", tone:"friendly", theme:"grand opening"
    })});
    if (!r.ok) throw new Error("content.generate failed");
    report.steps.push({ step:"content.generate", ok:true, quality:r.scores?.[0]?.overall });

    // Image generation (optional keys)
    try {
      const img = await expect2xx("/api/ai/image", { method:"POST", headers: hdrs(), body: JSON.stringify({ prompt:"minimal product shot, clean background", platform:"instagram" })});
      report.steps.push({ step:"image.generate", ok:true, id: img.id || true });
    } catch (e) {
      report.steps.push({ step:"image.generate", ok:false, skipped:true, reason:String(e) });
    }

    // 14-post campaign
    const camp = await expect2xx("/api/campaigns/generate", { method:"POST", headers: hdrs(), body: JSON.stringify({ platform:"instagram", theme:"opening week", postType:"promo" })});
    if (!Array.isArray(camp.posts) || camp.posts.length !== 14) throw new Error("campaign size != 14");
    report.steps.push({ step:"campaign.generate", ok:true });

    // Credits movement
    const bal = await expect2xx("/api/credits/me", { headers: hdrs() });
    if (typeof bal.remaining !== "number") throw new Error("no credit balance");
    report.steps.push({ step:"credits", ok:true, remaining: bal.remaining });

    // Library autosave (images/videos only)
    const lib = await expect2xx("/api/library?kind=image", { headers: hdrs() });
    report.steps.push({ step:"library.image", ok: Array.isArray(lib) });

    // Prepublish moderation block (bad caption)
    let post = await expect2xx("/api/posts", { method:"POST", headers: hdrs(), body: JSON.stringify({ kind:"image", caption:"NSFW lol" })});
    const pub = await fetch(base+"/api/posts/publish", { method:"POST", headers: hdrs(), body: JSON.stringify({ id: post.id })});
    report.steps.push({ step:"moderation.prepublish", ok: pub.status === 422 });

    report.ok = true;
    console.log(JSON.stringify(report, null, 2));
    process.exit(0);
  } catch (e) {
    report.error = String(e);
    console.log(JSON.stringify(report, null, 2));
    process.exit(1);
  }
})();
```

Add scripts to `package.json`:

```json
{
  "scripts": {
    "check:system": "tsx scripts/system_check.ts",
    "e2e": "playwright test"
  }
}
```

**Exit criteria:** `npm run check:system` returns JSON with `ok:true` locally.

---

# 5) Playwright E2E (strong coverage)

**Intent:** End-to-end flows that fail loudly if any feature is only “polished on the surface”.

Add/expand these specs (API mode to avoid UI flakiness; you can keep UI smokes separately):

1. **Content quality** (caption must pass thresholds)

```ts
// e2e/content-quality.spec.ts
import { test, expect } from "@playwright/test";
const base = process.env.E2E_BASE_URL!;
test("X promo meets quality thresholds", async ({ request }) => {
  const r = await request.post(`${base}/content/generate`, {
    headers: { "x-user-id": "starter-user-1" },
    data: { platform: "x", postType: "promo", tone: "friendly", theme: "grand opening" }
  });
  expect(r.ok()).toBeTruthy();
  const j = await r.json();
  expect(j.ok).toBeTruthy();
  expect(j.best.caption.length).toBeLessThanOrEqual(260);
  expect(j.best.hashtags.length).toBeGreaterThanOrEqual(3);
  expect(j.best.hashtags.length).toBeLessThanOrEqual(5);
  expect(j.scores?.[0]?.overall).toBeGreaterThanOrEqual(7);
});
```

2. **Image quality + library autosave**

```ts
// e2e/image-quality.spec.ts
import { test, expect } from "@playwright/test";
const base = process.env.E2E_BASE_URL!;
test("Instagram image generates and is saved to library", async ({ request }) => {
  const r = await request.post(`${base}/api/ai/image`, {
    headers: { "x-user-id": "starter-user-1" },
    data: { prompt: "clean studio product shot, soft light, white bg", platform: "instagram" }
  });
  expect(r.ok()).toBeTruthy();
  const lib = await request.get(`${base}/api/library?kind=image`, { headers: { "x-user-id": "starter-user-1" }});
  const items = await lib.json();
  expect(items.length).toBeGreaterThan(0);
});
```

3. **Video cap + plan gate**

```ts
// e2e/video-cap.spec.ts
import { test, expect } from "@playwright/test";
const base = process.env.E2E_BASE_URL!;
test("Starter cannot exceed 8s; 8s OK", async ({ request }) => {
  let r = await request.post(`${base}/api/ai/video/start`, {
    headers:{ "x-user-id": "starter-user-1" },
    data: { prompt:"hook-value-cta storyboard", durationSeconds: 12 }
  });
  expect(r.status()).toBe(422);

  r = await request.post(`${base}/api/ai/video/start`, {
    headers:{ "x-user-id": "starter-user-1" },
    data: { prompt:"hook-value-cta storyboard", durationSeconds: 8 }
  });
  expect(r.ok()).toBeTruthy();
});
```

4. **Campaign generator (exactly 14 posts, varied)**

```ts
// e2e/campaign-14.spec.ts
import { test, expect } from "@playwright/test";
const base = process.env.E2E_BASE_URL!;
test("Generates 14 varied posts with schedule", async ({ request }) => {
  const r = await request.post(`${base}/api/campaigns/generate`, {
    headers: { "x-user-id": "starter-user-1" },
    data: { platform:"instagram", theme:"opening week", postType:"promo" }
  });
  expect(r.ok()).toBeTruthy();
  const j = await r.json();
  expect(Array.isArray(j.posts)).toBeTruthy();
  expect(j.posts.length).toBe(14);
  const hooks = j.posts.map((p:any)=> String(p.caption).split("\n")[0]);
  // naive variety check: at least 10 unique hooks
  expect(new Set(hooks).size).toBeGreaterThanOrEqual(10);
});
```

5. **Moderation gates (pre-gen & pre-publish)**

```ts
// e2e/moderation-gates.spec.ts
import { test, expect } from "@playwright/test";
const base = process.env.E2E_BASE_URL!;
test("Blocked prompt & blocked publish", async ({ request }) => {
  let r = await request.post(`${base}/api/ai/text`, {
    headers: { "x-user-id": "starter-user-1" },
    data: { prompt: "Write a sexual violent rant" }
  });
  expect(r.status()).toBe(422);

  r = await request.post(`${base}/api/posts`, {
    headers: { "x-user-id": "starter-user-1" },
    data: { kind:"image", caption:"NSFW bad words" }
  });
  const post = await r.json();
  r = await request.post(`${base}/api/posts/publish`, {
    headers: { "x-user-id": "starter-user-1" },
    data: { id: post.id }
  });
  expect(r.status()).toBe(422);
});
```

6. **Payments (Stripe test) → credits**

```ts
// e2e/credits-purchase.spec.ts
import { test, expect } from "@playwright/test";
const base = process.env.E2E_BASE_URL!;
test("Stripe test purchase increases credits", async ({ request }) => {
  const before = await (await request.get(`${base}/api/credits/me`, { headers: { "x-user-id":"starter-user-1" } })).json();
  const buy = await request.post(`${base}/api/credits/purchase`, {
    headers: { "x-user-id":"starter-user-1" },
    data: { plan:"starter_pack" }
  });
  expect(buy.ok()).toBeTruthy();
  const after = await (await request.get(`${base}/api/credits/me`, { headers: { "x-user-id":"starter-user-1" } })).json();
  expect(after.remaining).toBeGreaterThan(before.remaining);
});
```

**Exit criteria:** All specs green locally; green in Replit’s CI before deploy.

---

# 6) Auto-Fix Loop (agent behavior on failures)

**Intent:** Don’t shrug; diagnose → patch → re-run.

For any failing test, the agent must:

1. **Classify** the failure:

   * 4xx: validation/moderation/plan gate logic—check middleware & thresholds.
   * 5xx: missing envs, unhandled errors, null assumptions—add guards.
   * Quality threshold miss: tighten prompt builder, add one refine pass, or adjust validators.

2. **Patch surgically**:

   * For content too long: add `tighten()` step (already in your quality engine).
   * For low hashtags: template add 3–5 niche tags; block spammy tags.
   * For missing autosave: ensure server’s image/video routes call `library.save()` after successful gen.
   * For moderation bypass: wire `requirePrepublishSafe()` on publish routes.

3. **Re-run targeted spec(s)**, then full suite.

4. **Update `/PROJECT_STATE.json`** with cause, diff summary, and result.

**Exit criteria:** No red tests remain.

---

# 7) CI Gate (Replit)

**Intent:** Deploy only when it’s truly working.

In your Replit CI (or a simple npm script invoked pre-deploy):

* `npm run check:system`
* `E2E_BASE_URL=$REPLIT_URL npm run e2e` (against preview)
* If any step fails → **abort deploy** with the JSON report.

**Exit criteria:** Deploy happens only with all checks green.

---

# 8) What “works 100%” means here (pass/fail)

* Health: `/health` 200; `/ready` 200 with DB.
* Auth: header-based test auth resolves users; session/JWT works in UI.
* Credits: deducted on success; refunded on failure; purchase updates balances.
* Content generation: captions hit **length, readability, hashtag count, CTA present**, and **qualityScore ≥ 7**; images/videos **exist, saved, and within plan gates**.
* Moderation: obvious violations blocked; edge cases to **Pending Approval**; pre-publish gate denies unsafe posts.
* Campaigns: exactly **14 posts**, varied hooks, scheduled.
* Library: images/videos auto-saved; text not saved.
* Payments: Stripe test webhook writes `credit_transactions`.
* Observability: `/metrics` returns counters > 0 after tests.

---

## TL;DR for the agent to execute now

1. Add the files I listed (config, evaluator, heuristics, scripts, specs).
2. Wire `/api/content/generate` if not already.
3. `npm i -D tsx @playwright/test sharp node-fetch`
4. `npm run check:system`
5. `E2E_BASE_URL=http://localhost:5000 npm run e2e`
6. Fix reds → commit → re-run until green.
7. Promote only on green.

This will make the agent actually **test, verify, and autocorrect** the content features (and everything around them) instead of waving it through. When you’re ready, I can add the `/metrics` endpoint and an **Admin Quality Dashboard** query so you can see quality scores, moderation decisions, and user feedback at a glance.
