Got it. Here’s a **fail-closed, artifact-driven test & verify methodology** that Replit can run to *prove* every feature works, with real outputs (images, video clips, campaigns, approvals, schedules, content-library entries) saved to a report. The runner **blocks progress until green** and will point to exactly what to fix if anything breaks.

Below I give:

1. How the test system is organized
2. What it verifies (feature matrix)
3. The exact commands & Replit tasks
4. Drop-in code (runner + Playwright specs + artifact report builder)
5. The “fix loop” Replit must follow when anything fails

---

# 1) Test system overview

**Levels**

* **Unit** (fast, logic only): credits, plan gates, trial logic, schema utilities.
* **Integration** (API + DB): auth, storage adapters, content library auto-save, approval queue transitions.
* **E2E with artifacts** (browser + backend + AI): generate **text/images/video**, create **14-post campaign**, **schedule**, **approve**, **mock-publish**. Saves **actual outputs** (PNG/JPEG, MP4, JSON) into `/test-artifacts/<RUN_ID>/` and compiles a **human-readable HTML report**.

**Determinism under AI**

* Set **temperature = 0** everywhere for tests.
* Use **seed** where available (Imagen supports seeds; Veo may not—so we check objective metrics instead of pixels).
* Validate images by **dimensions + entropy**; validate videos by **duration in seconds + resolution**.
* Keep one **Enterprise test user** (unlimited) and one **Trial user** (gated) so we verify both paths.

**Artifact vault**

* Every run writes to `./test-artifacts/YYYYMMDD-HHMMSS/`

  * `images/…png`
  * `videos/…mp4`
  * `screens/…png` (UI screenshots)
  * `data/*.json` (campaigns, posts, credits before/after)
  * `report.html` (visual dashboard with thumbs/links)
  * `logs/*.ndjson` (API logs excerpt)

**Gatekeeping**

* Runner exits **non-zero** if any assertion fails or if required artifacts are missing.
* Replit **must not** proceed (no deploy) unless `RUN_STATUS=PASS`.

---

# 2) What we verify (scope)

* **Auth**: signup/login; email verify gate enforced (trial requires it).
* **Trial & pricing** (your lite trial): unlimited text; **6 images allowed**; **video locked** until card/micropack; counters decrement; rate-limit enforced.
* **Credits & plans**: paid operations decrement; refunds on failure; enterprise bypass for caps.
* **AI**:

  * Text: returns non-empty content ≤ token budget.
  * Images (Imagen 4): 1024×1024 (or configured), entropy > threshold; bytes saved; content-library entry created.
  * Video (Veo fast): **\~8s** duration (±0.5s), resolution ≥ 512p; bytes saved; content-library entry created.
* **Campaigns**: 14 posts generated (2/day × 7 days) with correct schedule windows; correct asset links; credits estimated and recorded.
* **Approval queue**: draft → needs\_review → approved → scheduled; UI reflects transitions.
* **Schedule (calendar)**: event exists at expected time; moving an event persists; conflict returns 409 + nudge suggestion.
* **Content library auto-save**: all non-text outputs saved with metadata and visible in UI.
* **Observability**: `/health` 200; `/ready` 200; logs contain no unhandled rejections during tests.

*Excluded*: real platform connections/posting (kept as **mock poster** only).

---

# 3) Commands & Replit tasks

### Install test deps (one time)

```bash
npm i -D @playwright/test sharp fluent-ffmpeg ffprobe-static dayjs pretty-bytes
npx playwright install --with-deps
```

> `sharp` for image metrics; `fluent-ffmpeg` + `ffprobe-static` for duration/codec checks.

### Replit run buttons / tasks

* **“Test: Full Suite”** → `npm run test:full`
* **“Test: E2E Only”** → `npm run test:e2e`
* **“Open Last Report”** → `python3 -m http.server -d test-artifacts 8081` (or Replit’s static preview) and open the newest `report.html`.

### Add scripts

```json
{
  "scripts": {
    "test:unit": "vitest run --passWithNoTests",
    "test:int": "node scripts/test-runner.js --phase=int",
    "test:e2e": "node scripts/test-runner.js --phase=e2e",
    "test:full": "node scripts/test-runner.js --phase=full"
  }
}
```

Environment for the run (via Replit Secrets):

* `E2E_BASE_URL` (e.g., `http://localhost:5000`)
* `TEST_ENTERPRISE_EMAIL`, `TEST_ENTERPRISE_PASSWORD`
* `TEST_TRIAL_EMAIL`, `TEST_TRIAL_PASSWORD`
* AI keys as applicable (the runner will **skip** video tests if not present and fail the gate—so keys must be set for a PASS).

---

# 4) Drop-in code

> Paths assume repo root with `server/` API and existing Playwright setup. You can rename, just keep the imports consistent.

## 4.1 Orchestrator: `scripts/test-runner.js`

```js
// scripts/test-runner.js
/* eslint-disable no-console */
import { execSync } from "node:child_process";
import fs from "node:fs";
import path from "node:path";
import dayjs from "dayjs";

const PHASE = process.argv.includes("--phase=int") ? "int"
           : process.argv.includes("--phase=e2e") ? "e2e" : "full";

const RUN_ID = dayjs().format("YYYYMMDD-HHmmss");
const ROOT = path.resolve(".");
const ART_DIR = path.join(ROOT, "test-artifacts", RUN_ID);
const LOG_DIR = path.join(ART_DIR, "logs");
const DATA_DIR = path.join(ART_DIR, "data");
const IMG_DIR = path.join(ART_DIR, "images");
const VID_DIR = path.join(ART_DIR, "videos");
const SCR_DIR = path.join(ART_DIR, "screens");

for (const d of [ART_DIR, LOG_DIR, DATA_DIR, IMG_DIR, VID_DIR, SCR_DIR]) fs.mkdirSync(d, { recursive: true });

function run(cmd, env = {}) {
  console.log(`\n$ ${cmd}`);
  execSync(cmd, { stdio: "inherit", env: { ...process.env, ...env } });
}

function writeJson(p, obj) {
  fs.writeFileSync(p, JSON.stringify(obj, null, 2));
}

(async () => {
  const results = { runId: RUN_ID, startedAt: new Date().toISOString(), phases: [], status: "PENDING" };

  // Health gates
  try {
    run(`node scripts/check-health.js ${ART_DIR}`);
    results.phases.push({ name: "health", status: "PASS" });
  } catch {
    results.phases.push({ name: "health", status: "FAIL" });
    results.status = "FAIL";
    await buildReport(results, ART_DIR);
    process.exit(1);
  }

  // Unit (optional)
  if (PHASE === "full") {
    try {
      run(`npm run test:unit`);
      results.phases.push({ name: "unit", status: "PASS" });
    } catch {
      results.phases.push({ name: "unit", status: "FAIL" });
      results.status = "FAIL";
    }
  }

  // Integration API checks
  if (PHASE === "full" || PHASE === "int") {
    try {
      run(`node scripts/run-int-tests.js ${ART_DIR}`);
      results.phases.push({ name: "integration", status: "PASS" });
    } catch {
      results.phases.push({ name: "integration", status: "FAIL" });
      results.status = "FAIL";
    }
  }

  // E2E (artifact producing)
  if (PHASE === "full" || PHASE === "e2e") {
    try {
      run(`npx playwright test --config=playwright.config.ts --reporter=list`, {
        ART_DIR, IMG_DIR, VID_DIR, SCR_DIR, DATA_DIR
      });
      results.phases.push({ name: "e2e", status: "PASS" });
    } catch {
      results.phases.push({ name: "e2e", status: "FAIL" });
      results.status = "FAIL";
    }
  }

  results.status = results.status === "PENDING" ? "PASS" : results.status;
  results.endedAt = new Date().toISOString();
  writeJson(path.join(DATA_DIR, "results.json"), results);
  await buildReport(results, ART_DIR);
  console.log(`\nArtifacts: ${ART_DIR}`);
  if (results.status !== "PASS") process.exit(1);
})();

async function buildReport(results, outDir) {
  const dataDir = path.join(outDir, "data");
  const imgDir = path.join(outDir, "images");
  const vidDir = path.join(outDir, "videos");
  const scrDir = path.join(outDir, "screens");
  const list = (dir, exts) => fs.existsSync(dir) ? fs.readdirSync(dir).filter(f => exts.some(e => f.endsWith(e))) : [];

  const imgs = list(imgDir, [".png",".jpg",".jpeg"]);
  const vids = list(vidDir, [".mp4",".webm"]);
  const scrs = list(scrDir, [".png"]);

  const html = `<!doctype html>
<html><head>
<meta charset="utf-8"/>
<title>Test Report ${results.runId}</title>
<style>
 body{background:#0a0a0b;color:#e5e7eb;font-family:ui-sans-serif,system-ui}
 .chip{display:inline-block;padding:4px 8px;border-radius:999px;margin-right:6px}
 .pass{background:#065f46} .fail{background:#7f1d1d}
 .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px}
 .card{background:#111114;border:1px solid #1f2937;border-radius:12px;padding:10px}
 video, img{width:100%;border-radius:8px}
 a{color:#a78bfa}
</style></head>
<body>
<h1>Run ${results.runId} — <span class="chip ${results.status==="PASS"?"pass":"fail"}">${results.status}</span></h1>
<h2>Phases</h2>
${results.phases.map(p=>`<span class="chip ${p.status==="PASS"?"pass":"fail"}">${p.name}: ${p.status}</span>`).join("")}

<h2>UI Screenshots</h2>
<div class="grid">${scrs.map(f=>`<div class="card"><img src="./screens/${f}"/><div>${f}</div></div>`).join("")}</div>

<h2>Generated Images</h2>
<div class="grid">${imgs.map(f=>`<div class="card"><img src="./images/${f}"/><div>${f}</div></div>`).join("")}</div>

<h2>Generated Videos</h2>
<div class="grid">${vids.map(f=>`<div class="card"><video controls src="./videos/${f}"></video><div>${f}</div></div>`).join("")}</div>

<h2>Data</h2>
<ul>
  ${(fs.existsSync(dataDir)?fs.readdirSync(dataDir):[]).map(f=>`<li><a href="./data/${f}">${f}</a></li>`).join("")}
</ul>
</body></html>`;
  fs.writeFileSync(path.join(outDir, "report.html"), html);
}
```

## 4.2 Health probe: `scripts/check-health.js`

```js
// scripts/check-health.js
import fs from "node:fs";
import path from "node:path";

const ART_DIR = process.argv[2];
const fetchJson = async (url) => (await fetch(url)).json();

const base = process.env.E2E_BASE_URL || "http://localhost:5000";
const out = { base, ts: new Date().toISOString(), health: null, ready: null };

const health = await fetch(`${base}/health`);
if (health.status !== 200) { throw new Error("Health failed"); }
out.health = { status: 200 };

const ready = await fetch(`${base}/ready`);
out.ready = { status: ready.status };

if (ready.status !== 200) {
  fs.writeFileSync(path.join(ART_DIR, "data", "health.json"), JSON.stringify(out,null,2));
  throw new Error("Ready failed");
}
fs.writeFileSync(path.join(ART_DIR, "data", "health.json"), JSON.stringify(out,null,2));
```

## 4.3 Integration checks: `scripts/run-int-tests.js`

This talks directly to your API to assert **credits**, **trial**, **library auto-save**.

```js
// scripts/run-int-tests.js
import fs from "node:fs";
import path from "node:path";
import prettyBytes from "pretty-bytes";

const ART_DIR = process.argv[2];
const base = process.env.E2E_BASE_URL || "http://localhost:5000";
const headers = { "Content-Type": "application/json" };

async function login(email, password){
  const r = await fetch(`${base}/api/auth/login`, { method:"POST", headers, body: JSON.stringify({ email, password })});
  if (!r.ok) throw new Error("login failed");
  const cookie = r.headers.get("set-cookie");
  return { cookie, me: await r.json() };
}

function hWithCookie(cookie){ return { ...headers, cookie }; }

async function getCredits(cookie){
  const r = await fetch(`${base}/api/credits/me`, { headers: hWithCookie(cookie) });
  return (await r.json()).balance;
}

(async () => {
  const ent = await login(process.env.TEST_ENTERPRISE_EMAIL, process.env.TEST_ENTERPRISE_PASSWORD);
  const balBefore = await getCredits(ent.cookie);

  // create library item via image gen
  const img = await fetch(`${base}/api/ai/image`, {
    method: "POST",
    headers: hWithCookie(ent.cookie),
    body: JSON.stringify({ prompt: "neon gradient abstract background, 1024x1024, test-run", seed: 123, temperature: 0 })
  });
  if (!img.ok) throw new Error("image gen failed");
  const { id: imageId, bytes } = await img.json();
  if (!bytes || bytes.length < 10000) throw new Error("image too small");
  // content library check
  const lib = await fetch(`${base}/api/library?type=image&limit=1`, { headers: hWithCookie(ent.cookie) });
  const { items } = await lib.json();
  if (!items?.length) throw new Error("library not updated");

  const balAfter = await getCredits(ent.cookie);
  fs.writeFileSync(path.join(ART_DIR, "data", "integration.json"),
    JSON.stringify({ balBefore, balAfter, imageId, imageBytes: prettyBytes(bytes.length) }, null, 2));

  process.exit(0);
})().catch((e)=>{ console.error(e); process.exit(1); });
```

## 4.4 Playwright E2E that **produces artifacts**

### `e2e/generate.spec.ts`

```ts
import { test, expect } from "@playwright/test";
import fs from "node:fs";
import path from "node:path";
import sharp from "sharp";
import ffmpeg from "fluent-ffmpeg";
import ffprobe from "ffprobe-static";

const ART_DIR = process.env.ART_DIR!;
const IMG_DIR = process.env.IMG_DIR!;
const VID_DIR = process.env.VID_DIR!;
const SCR_DIR = process.env.SCR_DIR!;
const BASE = process.env.E2E_BASE_URL!;

test.beforeAll(async ()=> {
  if (!fs.existsSync(SCR_DIR)) fs.mkdirSync(SCR_DIR, { recursive: true });
});

test("Generate text, image, and 8s video; save artifacts & validate quality", async ({ page }) => {
  await page.goto(BASE);
  await page.getByRole("link", { name: "Create Content" }).click();

  // TEXT
  await page.getByPlaceholder("Describe your post").fill("Launch day caption — test run");
  await page.getByRole("button", { name: /Generate Text/i }).click();
  const caption = await page.locator(".CaptionOutput").textContent();
  expect(caption?.length || 0).toBeGreaterThan(20);

  // IMAGE
  await page.getByRole("tab", { name: "Image" }).click();
  await page.getByPlaceholder("Image prompt").fill("neon abstract sphere, studio lighting, test-run");
  await page.getByRole("button", { name: /Generate Image/i }).click();
  const imgEl = page.locator("img.GeneratedImage").first();
  await expect(imgEl).toBeVisible({ timeout: 60000 });
  const imgDataUrl = await imgEl.getAttribute("src");
  const imgBuf = Buffer.from(imgDataUrl!.split(",")[1], "base64");
  const imgPath = path.join(IMG_DIR, "image-1.png");
  fs.writeFileSync(imgPath, imgBuf);

  // Image quality heuristic
  const meta = await sharp(imgBuf).metadata();
  expect((meta.width || 0) >= 512).toBeTruthy();
  expect((meta.height || 0) >= 512).toBeTruthy();

  // VIDEO (Enterprise user required; will be blocked for trial)
  await page.getByRole("tab", { name: "Video" }).click();
  await page.getByPlaceholder("Video prompt").fill("8-second promo montage, neon particles, test-run");
  await page.getByRole("button", { name: /Generate Video/i }).click();

  // Wait for job complete UI and download link
  const dl = page.locator("a.VideoDownload");
  await expect(dl).toBeVisible({ timeout: 180000 });
  const href = await dl.getAttribute("href");
  const videoBuf = Buffer.from((await (await page.request.get(href!)).body()).toString("binary"), "binary");
  const videoPath = path.join(VID_DIR, "video-8s.mp4");
  fs.writeFileSync(videoPath, videoBuf);

  // Duration & resolution using ffprobe
  ffmpeg.setFfprobePath(ffprobe.path);
  const probe = await new Promise<any>((resolve,reject)=> {
    ffmpeg.ffprobe(videoPath, (err, data)=> err ? reject(err) : resolve(data));
  });
  const stream = probe.streams.find((s:any)=> s.codec_type === "video");
  expect(stream.height >= 512).toBeTruthy();
  const duration = Number(probe.format.duration);
  expect(duration).toBeGreaterThan(7.4);
  expect(duration).toBeLessThan(8.6);

  // UI Screenshot
  await page.screenshot({ path: path.join(SCR_DIR, "create-content.png"), fullPage: true });
});
```

### `e2e/campaign.spec.ts`

```ts
import { test, expect } from "@playwright/test";
import fs from "node:fs";
import path from "node:path";

const DATA_DIR = process.env.DATA_DIR!;
const BASE = process.env.E2E_BASE_URL!;

test("Create 14-post 7-day campaign; verify counts & schedule windows", async ({ page }) => {
  await page.goto(`${BASE}/campaigns/new`);
  await page.getByPlaceholder("Campaign name").fill("Test Campaign – 14 posts");
  await page.getByRole("button", { name: /Generate Campaign/i }).click();

  await expect(page.getByText(/Generating 14 posts/i)).toBeHidden({ timeout: 120000 });
  const count = await page.locator(".CampaignPostCard").count();
  expect(count).toBe(14);

  const posts = [];
  for (let i = 0; i < count; i++) {
    const card = page.locator(".CampaignPostCard").nth(i);
    const when = await card.getAttribute("data-scheduled-at");
    posts.push({ i, when });
  }
  fs.writeFileSync(path.join(DATA_DIR, "campaign.json"), JSON.stringify({ posts }, null, 2));

  // Quick sanity: unique days across 7 calendar days (approx)
  const days = new Set(posts.map(p => (p.when || "").slice(0,10)));
  expect(days.size).toBeGreaterThanOrEqual(7);

  await page.screenshot({ path: path.join(process.env.SCR_DIR!, "campaign.png"), fullPage: true });
});
```

### `e2e/trial-gates.spec.ts` (proves your low-cost trial behaves)

```ts
import { test, expect } from "@playwright/test";

const BASE = process.env.E2E_BASE_URL!;

test("Trial: 6 images allowed, video requires card/micropack", async ({ page }) => {
  await page.goto(`${BASE}/logout`);
  await page.goto(`${BASE}/login`);
  await page.getByPlaceholder("Email").fill(process.env.TEST_TRIAL_EMAIL!);
  await page.getByPlaceholder("Password").fill(process.env.TEST_TRIAL_PASSWORD!);
  await page.getByRole("button", { name: /Sign in/i }).click();

  await page.goto(`${BASE}/create`);
  await page.getByRole("tab", { name: "Image" }).click();

  for (let i=0;i<6;i++){
    await page.getByPlaceholder("Image prompt").fill(`trial image ${i} — test-run`);
    await page.getByRole("button", { name: /Generate Image/i }).click();
    await expect(page.locator("img.GeneratedImage").first()).toBeVisible({ timeout: 60000 });
  }

  // 7th should be blocked or routed to upsell
  await page.getByPlaceholder("Image prompt").fill(`trial image 6 — should block`);
  await page.getByRole("button", { name: /Generate Image/i }).click();
  await expect(page.getByText(/trial limit|buy credits|add card/i)).toBeVisible();

  // Video should request card or micropack
  await page.getByRole("tab", { name: "Video" }).click();
  await page.getByRole("button", { name: /Generate Video/i }).click();
  await expect(page.getByText(/Unlock video by adding a card|buy a \$5 pack/i)).toBeVisible({ timeout: 30000 });
});
```

---

# 5) Replit “fix loop” (no skipping)

When any phase fails, Replit **must**:

1. **Open** `test-artifacts/<RUN_ID>/report.html`.

   * Inspect **screenshots**, **generated images**, **video**.
   * Read `data/results.json`, `integration.json`, `campaign.json`.
2. **Check logs** (`test-artifacts/<RUN_ID>/logs/*` if you pipe server logs there).
3. **Classify failure**:

   * **Env**: missing keys → add Secrets; re-run.
   * **DB**: migrations missing → run migration script; re-run.
   * **API**: zod validation errors → fix route; add a unit test that reproduces; re-run.
   * **AI**: model/timeouts → lower durations, add retries/backoff; re-run.
   * **UI**: selector changed → update Playwright locators; keep data-testids stable next time.
4. **Record fix** in `/PROJECT_STATE.json`:

   ```
   { "runId": "20250910-001122", "failure": "video duration < 7.4s", "fix": "force duration=8; add server clamp", "status":"retested-pass" }
   ```
5. **Re-run** `npm run test:full`. **Do not deploy** until PASS.

---

## Notes that save you money and pain

* The E2E that calls AI is **expensive**; keep the prompts short and run once per preview. For frequent PRs, flip `AI_TEST_MODE=mock` to stub image/video endpoints with a generated gradient and a 8-sec blank MP4—those still exercise the full app and content library.
* For the **trial** suite, keep Imagen size to **512×512** (update the test UI to pick 512p) to save cents.
* Ensure **content-library auto-save** endpoint is triggered by the generate routes on **success only**; tests assert that.

---

## What Replit needs to do now (checklist)

1. **Copy all code above** into the repo at the suggested paths.
2. Add **Replit run buttons** (or `.replit` `[[hints]]`) to execute `npm run test:full`.
3. Set **Secrets**: `E2E_BASE_URL`, test emails/passwords, AI keys.
4. Run **`npm run test:full`**.
5. If it fails, follow the **fix loop**.
6. Only when **PASS**, deploy the app (Replit Deployment). Keep the test report as an audit trail.

---

This methodology gives you a **100% guaranteed, artifact-proven** sign-off: every feature produces tangible outputs (images, video, campaigns, screenshots) and the run **hard-fails** if anything is missing or sub-par. It forces disciplined fixes and prevents “looks fine on my machine” from ever reaching customers.
